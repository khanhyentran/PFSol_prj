--- imx219_ori.c	2018-08-10 11:42:07.239422251 +0700
+++ imx219_modify_to_work_with_Linux4.14.c	2018-08-10 11:46:58.642848524 +0700
@@ -7,12 +7,14 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/clk.h>//RVC add
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/v4l2-mediabus.h>
 #include <linux/slab.h>
 #include <linux/videodev2.h>
 #include <linux/module.h>
+//#include <media/v4l2-mediabus.h>
 #include <media/soc_camera.h>
 #include <media/v4l2-async.h>
 #include <media/v4l2-clk.h>
@@ -31,6 +33,95 @@
 	u16 addr;
 	u8 val;
 };
+
+#define V4L2_MBUS_FROM_MEDIA_BUS_FMT(name)	\
+	V4L2_MBUS_FMT_ ## name = MEDIA_BUS_FMT_ ## name
+
+enum v4l2_mbus_pixelcode {//RVC add to fix error pixelcode
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(FIXED),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB444_2X8_PADHI_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB444_2X8_PADHI_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB555_2X8_PADHI_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB555_2X8_PADHI_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(BGR565_2X8_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(BGR565_2X8_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB565_2X8_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB565_2X8_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB666_1X18),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB888_1X24),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB888_2X12_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(RGB888_2X12_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(ARGB8888_1X32),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(Y8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UV8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY8_1_5X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY8_1_5X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV8_1_5X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU8_1_5X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY8_2X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY8_2X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV8_2X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU8_2X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(Y10_1X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY10_2X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY10_2X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV10_2X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU10_2X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(Y12_1X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY8_1X16),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY8_1X16),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV8_1X16),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU8_1X16),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YDYUYDYV8_1X16),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY10_1X20),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY10_1X20),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV10_1X20),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU10_1X20),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUV10_1X30),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(AYUV8_1X32),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY12_2X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY12_2X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV12_2X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU12_2X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(UYVY12_1X24),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(VYUY12_1X24),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YUYV12_1X24),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(YVYU12_1X24),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGBRG8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGRBG8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SRGGB8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_ALAW8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGBRG10_ALAW8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGRBG10_ALAW8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SRGGB10_ALAW8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_DPCM8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGBRG10_DPCM8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGRBG10_DPCM8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SRGGB10_DPCM8_1X8),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_2X8_PADHI_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_2X8_PADHI_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_2X8_PADLO_BE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_2X8_PADLO_LE),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR10_1X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGBRG10_1X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGRBG10_1X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SRGGB10_1X10),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SBGGR12_1X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGBRG12_1X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SGRBG12_1X12),
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(SRGGB12_1X12),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(JPEG_1X8),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(S5C_UYVY_JPEG_1X8),
+
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(AHSV8888_1X32),
+};
+
 static const struct imx219_reg miscellaneous[] = {
 	{ 0x30EB, 0x05 }, /* Access Code for address over 0x3000 */
 	{ 0x30EB, 0x0C }, /* Access Code for address over 0x3000 */
@@ -128,6 +219,9 @@
 	struct v4l2_ctrl_handler	ctrl_handler;
 	const struct imx219_datafmt	*fmt;
 	struct v4l2_clk			*clk;
+	struct media_pad		pad;//RVC add for pad_entity
+	struct clk			*xclk;//RVC add for enable clk
+	struct mutex			lock;//RVC add for lock
 	struct v4l2_rect		crop_rect;
 	int				hflip;
 	int				vflip;
@@ -169,6 +263,7 @@
 	tx[0] = addr >> 8;
 	tx[1] = addr & 0xff;
 	tx[2] = data;
+	printk("reg_write data %x\n", data);
 	ret = i2c_transfer(adap, &msg, 1);
 	mdelay(2);
 	return ret == 1 ? 0 : -EIO;
@@ -196,6 +291,8 @@
 			 addr, client->addr);
 		return ret;
 	}
+	dev_warn(&client->dev, "Reading register %x from %x, buf[0] %x ok\n",
+			 addr, client->addr, buf[0]);
 	return buf[0];
 }
 static int reg_write_table(struct i2c_client *client,
@@ -203,6 +300,7 @@
 {
 	const struct imx219_reg *reg;
 	int ret;
+	printk("reg_write_table\n");
 	for (reg = table; reg->addr != IMX219_TABLE_END; reg++) {
 		ret = reg_write(client, reg->addr, reg->val);
 		if (ret < 0)
@@ -217,6 +315,7 @@
 	struct imx219 *priv = to_imx219(client);
 	u8 reg = 0x00;
 	int ret;
+printk("imx219_s_stream\n");
 	if (!enable)
 		return reg_write_table(client, stop);
 	ret = reg_write_table(client, miscellaneous);
@@ -391,9 +490,23 @@
 static int imx219_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	//struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
 	struct imx219 *priv = to_imx219(client);
-	return soc_camera_set_power(&client->dev, ssdd, priv->clk, on);
+	//return soc_camera_set_power(&client->dev, ssdd, priv->clk, on);//RVC
+	int ret = 0;
+	printk("imx219_s_power\n");
+	mutex_lock(&priv->lock);
+	
+	ret = clk_prepare_enable(priv->xclk);
+	if (ret < 0) {
+		dev_err(&client->dev, "clk prepare enable failed\n");
+		goto out;
+	}
+
+out:
+	mutex_unlock(&priv->lock);
+	
+	return ret;
 }
 /* V4L2 ctrl operations */
 static int imx219_s_ctrl_test_pattern(struct v4l2_ctrl *ctrl)
@@ -515,14 +628,14 @@
 /* Various V4L2 operations tables */
 static struct v4l2_subdev_video_ops imx219_subdev_video_ops = {
 	.s_stream	= imx219_s_stream,
-	.cropcap	= imx219_cropcap,
+	/*.cropcap	= imx219_cropcap,
 	.g_crop		= imx219_g_crop,
 	.s_crop		= imx219_s_crop,
 	.enum_mbus_fmt	= imx219_enum_mbus_fmt,
 	.g_mbus_fmt	= imx219_g_mbus_fmt,
 	.try_mbus_fmt	= imx219_try_mbus_fmt,
 	.s_mbus_fmt	= imx219_s_mbus_fmt,
-	.g_mbus_config	= imx219_g_mbus_config,
+	.g_mbus_config	= imx219_g_mbus_config,*///RVC
 };
 static struct v4l2_subdev_core_ops imx219_subdev_core_ops = {
 	.s_power	= imx219_s_power,
@@ -541,9 +654,11 @@
 	u32 lot_id;
 	u16 chip_id;
 	int ret;
+
 	ret = imx219_s_power(subdev, 1);
 	if (ret < 0)
 		return ret;
+printk("imx219_video_probe check chip ID \n");
 	/* Check and show model, lot, and chip ID. */
 	ret = reg_read(client, 0x0000);
 	if (ret < 0) {
@@ -605,6 +720,7 @@
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx219 *priv = to_imx219(client);
 	int ret;
+printk("imx219_ctrls_init\n");
 	v4l2_ctrl_handler_init(&priv->ctrl_handler, 10);
 	v4l2_ctrl_new_std(&priv->ctrl_handler, &imx219_ctrl_ops,
 			  V4L2_CID_HFLIP, 0, 1, 1, 0);
@@ -648,12 +764,15 @@
 {
 	struct imx219 *priv;
 	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
-	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	//struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	struct v4l2_subdev *sd;
 	int ret;
-	if (!ssdd) {
-		dev_err(&client->dev, "IMX219: missing platform data!\n");
-		return -EINVAL;
-	}
+	u8 reg = 0x00;
+	printk("imx219_probe \n");
+	//if (!ssdd) {
+	//	dev_err(&client->dev, "IMX219: missing platform data!\n");
+		//return -EINVAL;//RVC
+	//}
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		dev_warn(&adapter->dev,
 			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");
@@ -662,44 +781,86 @@
 	priv = devm_kzalloc(&client->dev, sizeof(struct imx219), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
-	priv->clk = v4l2_clk_get(&client->dev, "mclk");
+	/*RVC replace v4l2_clk by devm_clk*/
+	/*
+	priv->clk = v4l2_clk_get(&client->dev, "xclk");//mclk
 	if (IS_ERR(priv->clk)) {
 		dev_info(&client->dev, "Error %ld getting clock\n",
 			 PTR_ERR(priv->clk));
 		return -EPROBE_DEFER;
+	}*/
+		
+	/* get system clock (xclk) */
+	priv->xclk = devm_clk_get(&client->dev, NULL);
+	if (IS_ERR(priv->xclk)) {
+		dev_err(&client->dev, "could not get xclk");
+		return PTR_ERR(priv->xclk);
 	}
+	//RVC1 end
 	priv->fmt = &imx219_colour_fmts[0];
 	priv->crop_rect.left	= 0;
 	priv->crop_rect.top	= 0;
 	priv->crop_rect.width	= IMX219_WIDTH;
 	priv->crop_rect.height	= IMX219_HEIGHT;
 	v4l2_i2c_subdev_init(&priv->subdev, client, &imx219_subdev_ops);
-	ret = soc_camera_power_init(&client->dev, ssdd);
+	printk("imx219_probe 1\n");	
+	/*RVC replace soc_power by enable_clk*/
+	/*ret = soc_camera_power_init(&client->dev, ssdd);
 	if (ret < 0)
-		goto eclk;
+		goto eclk;*/ 
+	
+/*RVC add pad*/
+	mutex_init(&priv->lock);
+
+	sd = &priv->subdev;
+	//v4l2_i2c_subdev_init(sd, client, &ov5647_subdev_ops);
+	//priv->sd.internal_ops = &ov5647_subdev_internal_ops;
+	priv->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &priv->pad);
+	if (ret < 0){
+		printk("imx219 Failed to add pad\n");	
+		goto mutex_remove;
+	}
+//RVC
+
 	ret = imx219_ctrls_init(&priv->subdev);
+	printk("imx219_probe 2\n");
 	if (ret < 0)
 		goto eclk;
+	printk("imx219_probe 3\n");
 	ret = imx219_video_probe(client);
 	if (ret < 0)
 		goto eclk;
+	
 	ret = v4l2_async_register_subdev(&priv->subdev);
 	if (ret < 0)
 		goto eclk;
+	printk("imx219_probe 4 camera driver probed ok\n");
+//RVC add stream
+	/* If enabled, apply settings immediately */
+	//reg = reg_read(client, 0x0100);
+	//if ((reg & 0x1f) == 0x01)
+		imx219_s_stream(sd, 1);
 	return 0;
 eclk:
 	v4l2_clk_put(priv->clk);
 	return ret;
+mutex_remove:
+	mutex_destroy(&priv->lock);
+	return ret;
 }
 static int imx219_remove(struct i2c_client *client)
 {
-	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	//struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);RVC remove
 	struct imx219 *priv = to_imx219(client);
 	v4l2_async_unregister_subdev(&priv->subdev);
 	v4l2_ctrl_handler_free(&priv->ctrl_handler);
 	v4l2_clk_put(priv->clk);
-	if (ssdd->free_bus)
-		ssdd->free_bus(ssdd);
+	//if (ssdd->free_bus)
+	//	ssdd->free_bus(ssdd);//RVC remove
 	return 0;
 }
 static const struct i2c_device_id imx219_id[] = {
@@ -707,8 +868,16 @@
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, imx219_id);
+
+static const struct of_device_id imx219_of_match[] = {
+	{ .compatible = "sony,imx219" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, ov5647_of_match);
+
 static struct i2c_driver imx219_i2c_driver = {
 	.driver = {
+		.of_match_table = of_match_ptr(imx219_of_match),
 		.name = "imx219",
 	},
 	.probe		= imx219_probe,
@@ -719,3 +888,5 @@
 MODULE_DESCRIPTION("Sony IMX219 Camera driver");
 MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
 MODULE_LICENSE("GPL v2");
+
+
